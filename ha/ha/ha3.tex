\section*{Деревья и пути}
\begin{enumerate}
	\item Назовем ребро дерева тяжелым, если размер поддерева, его нижнего конца больше либо равен 
	половине размера поддерева его верхнего конца. Покроем дерево путями следующим способом: из 
	каждой вершины, в которую входит тяжелое ребро будем идти вверх, пока не дойдем до корня, 
	или пока не пройдем по легкому ребру. Такое покрытие называется 
	\textbf{«Heavy-Light-Decomposition»}. Докажите, что путь из любой вершины в корень пересекает 
	не более чем $\log n$ путей из покрытия, где $n$ — количество вершин.
	
	\textbf{Решение.} 
	
	Рассмотрим путь от произвольной вершины до корня. Будем двигаться по нему 
	в обратном направлении - от корня к вершине. При переходе к следующей вершине возможны два 
	случая: прошли по тяжелому ребру $\Rightarrow$ остались в прежнем пути, либо прошли по 
	легкому ребру, значит начался другой путь. Заметим, что когда проходим по легкому ребру, то 
	размер поддерева, в котором находится вершина уменьшился как минимум в 2 раза (иначе это 
	ребро было бы тяжелым). Таким образом, смена пути покрытия в пути от корня к произвольной 
	вершине влечет за собой уменьшение не менее чем в 2 раза размер поддерева, значит и путей 
	покрытия, которые пересеклись с рассмотренным путем не более чем $\log_2 n$.
	
	\item Дано дерево, у каждой вершины есть вес. Запросы: 
	изменить вес вершины; 
	найти максимум на пути из $u$ в $v$. $\langle O(n \log n)$, $O(\log^2 n) \rangle$. 
	
	Hint: предыдущая задача.
	
	\item Даны подвешенное дерево и его Эйлеров обход. Придумайте, как за $O(\log n)$ обновить 
	Эйлеров	обход при переподвешивании дерева за другую вершину (для разных вариантов обхода).
	
	\item Пусть есть много неподвешенных деревьев. Запросы \textit{online}:
	\begin{itemize}
		\item соединить ребром вершины $v$ и $u$ разных деревьев,
		\item удалить ребро между вершинами $v$ и $u$,
		\item проверить, в одной ли компоненте лежат вершины $u$ и $v$.
	\end{itemize}
	
	$O(n)$ на предобработку, $O(\log n)$ на запрос ($n$ — суммарный размер деревьев).
	
	\textbf{Решение.} 
	
	Заметим, что для подвешенных деревьев мы умеем решать эту задачу. В предыдущей задаче мы 
	научились обновлять за $O(\log n)$ Эйлеров обход дерева при переподвешивании за другую 
	вершину.
	
	Предобработка: подвесим все имеющиеся деревья за произвольную вершину, найдем для них 
	Эйлеровы обходы  с построим Декартово дерево по неявному ключу. 
	
	Ответы на запросы:
	
	\textit{соединить ребром вершины $v$ и $u$ разных деревьев}. Переподвесить дерево, в 
	котором находится вершина $u$ за эту вершину. Соединить полученное подвешенное дерево с 
	вершиной $v$.
	
	\textit{удалить ребро между вершинами $v$ и $u$}. Переподвесим дерево за $u$. Теперь $v$ 
	является корнем своего поддерева, задача сведена к уже решенной.
	
	\textit{проверить, в одной ли компоненте лежат вершины $u$ и $v$.} В любой момент времени 
	все деревья подвешены. Такая задача уже решена.
	
	
	
	\item Дано дерево из n вершин, по которому бегают муравьи. Вам поступает $m$
	запросов вида $a, b$, что означает, что очередной муравей пробежал из вершины $a$ в вершину 
	$b$.
	
	\begin{enumerate}
		\item Выведите, сколько раз муравьи пробежали через каждое из ребер за $O(n + m)$.
		
		\textbf{Решение. } Заметим, что, если дерево подвешено, то с каждым ребром можно 
		однозначно связать одну вершину, которая является его нижним концом. Тогда можно 
		считать, что мы прошли через ребро в том случае, если посетили его нижний конец. 
		Воспользуемся тем, что умеем искать LCA за $O(1)$. 
		
		Выполним следующие действия: с начала подвесим дерево за какую-то из вершин. Построим 
		LCA (c $O(1)$) для подвешенного дерева. Для запроса вида $a$, $b$ найдем LCA этих 
		вершин - вершина $c$. К значению в вершинах $a$, $b$ добавим единицу (т.к. ребра, 
		которые заканчиваются в этой вершине посещаются по одному разу), а от значения в 
		вершине $c$ вычтем двойку(т.к. мы добавили две единицы к поддереву, но через 
		соответствующее ребро не ходили). После этого осталось обойти дерево в глубину и найти 
		сумму значений в вершнах поддерева для каждой вершины (т.к. если были пути в вершины 
		поддерева, то они и проходили через вершину - корень этого поддерева). По построению 
		,полученное значение в каждой из вершин (кроме корня) будет равно количеству походов 
		через ребро, 
		нижним концов которого является данная вершина.
		\item А теперь вам онлайн поступают вопросы про каждое из ребер (эти запросы могут 
		поступить в любой момент, в том числе до окончания муравьиных пробегов). Обработайте 
		каждый из двух типов запросов за $log^2 n$ с предподсчетом за $O(n \log n)$.
		
		Сложность алгоритма равна сложности подвешивания дерева $O(n)$ + сложность построения 
		LCA $O(n)$ + обработка запросов $O(m)$ + $DFS$ $O(n)$. Итоговая сложность - $O(n + m)$.
	\end{enumerate}
\end{enumerate}


