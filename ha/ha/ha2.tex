\section*{RMQ и LCA}
\begin{enumerate}
	\item Дано дерево из одной вершины. Требуется уметь отвечать $online$ за $O(\log n)$ на
	запрос: подвесить новую вершину $u$ к вершине дерева $v$ и вернуть диаметр дерева. Диаметр
	дерева — длина самого длинного простого пути в дереве. 
	
	\textbf{Решение.} 
	
	Заметим, что самый длинный путь в дереве - путь между какими-либо двумя листьями (пусть это 
	не так, и существует путь, хотя бы одна вершина которого - не лист. Но тогда можно 
	продолжить этот путь минимум на 1 вершину. Значит путь не максимальный. Противоречие.)
	
	Заметим, что при добавлении вершины мы всегда добавляем лист. 
	
	Ещё одно \textbf{ утверждение}: \textit{в дереве не может быть два пути максимальной длины 
	(обозначим макс. длину пути $M$), которые не пересекаются.} (Если они есть, то можно 
	построить путь большей длины: выберем самую верхнюю вершину первого пути, и самую верхнюю 
	вершину второго пути. Они не могут совпадать, и между ними есть хотя бы одно ребро. Каждая 
	из этих вершин разбивает соответствующий путь на две части. Выберем из этих частей бОльшие, 
	длина каждой части, минимум, $M / 2$. А значит, можно построить путь длиной не менее $M + 
	1$, что противоречит о максимальности выбранных путей.)
	
	\textbf{Следствие.} Все пути максимальной длины в дереве пересекаются. 
	
	Заметим, что длина максимального пути может измениться не более чем на единицу(т.к. 
	добавляется только 1 вершина и одно ребро), и изменится она только лишь в том случае, когда 
	вершина добавляется к одному из концов какого-либо пути максимальной длины.
	
	Теперь заметим, что поддерживая концевые вершины одного из кратчайших путей, можно понять, 
	изменяет ли добавление вершины длину пути наибольшей длины. Для этого воспользуемся $LCA$, 
	и будем хранить на каком расстоянии от корня находится каждая вершина. Так же будем хранить 
	две вершины(обозначим $v_b, v_e$), которые образуют путь максимальной длины в дереве 
	(сначала она равны одной заданной вершине). При добавлении вершины $u$ будем искать, при 
	помощи $LCA$ ближайшего общего предка для пар вершин $u$, $v_b$, и так же $u$, $v_e$. И, 
	зная расстояния от корня для всех вершин можно будет рассчитать длину путей из $u$ в $v_b$ 
	и из $u$ в $v_e$. Если длина какого либо из них превзойдет длину пути $v_b \to v_e$, то 
	заменим соответствующую вершину на $u$ и вернем полученное значение длины максимального 
	пути.
	
	\textbf{Оценка сложности.} 
	
	Использование $LCA$ имеет сложность $O(\log n)$. Операции вычисления длин двух путей и их 
	сравнение с длинами старых путей, очевидно, константные.
	
	\textbf{Корректность.} 
	
	Разбором случаев пересечений пары двух путей максимальной длины можно получить, что если
	добавленное значение увеличивает один из путей макс. длины, то можно увеличить и старый путь макс.
	длины, заменив одну из его граничных вершин. 
	
	\item Дан ориентированный граф, в котором исходящая степень каждой вершины равна единице.
	Запросы $online$: из вершины $v$ сделать $k$ шагов вперед.
	\begin{itemize}
		\item Предподсчет: $O(n \log k\max)$, время на запрос: $O(\log k)$.
		\item Предподсчет: $O(n \log n)$, время на запрос: $O(\log \min(k, n))$.
	\end{itemize}
	
	\textbf{Решение.}
	
	\begin{itemize}
		\item Предподсчет: $O(n \log k\max)$, время на запрос: $O(\log k)$.
		
		Сделаем скип-лист через каждые $1, 2, 4, 8, 16, ..., k_max$ элементов, тогда сможем за $O(\log k)$ 
		отвечать на запрос.
		\item Предподсчет: $O(n \log n)$, время на запрос: $O(\log \min(k, n))$.
		
		В этом случае нужно воспользоваться структурой графа. В графе обязан быть хотя бы один 
		цикл, поэтому при больших $k$ движение вперед рано или поздно зациклится. Идея в том, 
		чтобы дойти до вершины из цикла, затем убрать лишние циклы из $k$, и пройти оставшееся 
		количество шагов по скиплисту.
		
		На первом шаге алгоритма найдем все циклы в графе с помощью какого-либо обхода, и для 
		каждой вершины сохраним 0, если она не входит ни в какой цикл, и значение длины цикла, 
		если входит. Так же построим скип-лист через каждые $1, 2, 4, 8, 16, ..., n$ вершин. 
		При запросе так же будем двигаться по скип листу, до тех пор, пока не сделаем все шаги, 
		либо пока не попадем в вершину которая лежит в каком-либо цикле. После этого удалим из 
		оставшегося числа шагов полные циклы, и выполним те шаги, что остались. 
		
		\textbf{Оценка сложности.} 
		
		Т.к. теперь скип-лист строится до шага длины $n$, то преподчсчет займет $O(n \log n)$. 
		А т.к. добраться до цикла можно в худшем случае за $O(\log n )$ шагов, а выбросить 
		циклы из значения $k$ займет $O(1)$, то время на запрос составит $O(\log \min(k,n))$. 
	\end{itemize}
	
	\item Дан массив чисел длины $n$. За $O(\log n)$ в $online$ обрабатывать запросы:
	\begin{itemize}
		\item посчитать сумму кубов чисел на отрезке $[L, R]$
		\item прибавить $x$ ко всем числам на отрезке $[L, R]$
		\item получить значение $i$-го числа
	\end{itemize}
	
	\textbf{Решение.}
	
	Воспользуемся $RMQ$, в узле будем хранить значение суммы, суммы квадратов и кубов.
	
	Почему нужно именно это? Рассмотрим сумму кубов на отрезке $[L, R]$:
	\begin{align*}
	\sum (a_i + x)^3 &= \sum (a_i^3 + 3a_i^2x + 3a_ix^2 + x^3) = \sum (a_i^3) + 3x\sum(a_i^2) + 3x^2\sum a_i + (R-L)x^3 \\
	\sum (a_i + x)^2 &= \sum (a_i^2 + 2a_ix + x^2) = \sum (a_i^2) + 2x\sum(a_i) + (R-L)x^2\\
	\sum (a_i + x) &= \sum(a_i) + (R-L)x
	\end{align*}
	
	То есть имея эти три значения, можно пересчитывать сумму кубов на отрезке, не пересчитывая 
	её на подотрезках, выполняя второй запрос за $O(\log n)$. 
	
	Заметим теперь, что на подотрезках мы не вычислили сумму кубов, квадратов и значений. Для 
	этого в каждом узле будем хранить два отложенных вычисления - сколько нужно добавить в 
	левый подотрезок и сколько нужно добавить в правый подотрезок. И при выполнении запросов эти отложенные 
	вычисления нужно проталкивать ниже. 
	
	\textbf{Оценка сложности.} 
	
	Достаточно заметить, что пересчет сумм кубов, квадратов и самих значений занимает $O(1)$, значит сложность 
	запроса составит сложность работы с $RMQ$, то есть - $O(\log n)$.
	
	\item Дана скобочная последовательность из круглых скобок длины $n$. Запросы: является ли 
	отрезок $[L, R]$ правильной скобочной последовательностью; изменить $i$-ю скобку. $O(\log 
	n)$, $online$.
	
	\textbf{Решение.}
	
	Введём понятие баланса скобочной последовательности - разность между количеством 
	открывающим и закрывающих скобок. Значение баланса можно вычислять на префиксе скобочной 
	последовательности. Пусть $a_i$ - значение баланса на префиксе длины $i$. Тогда для того, 
	чтобы отрезок $[L, R]$ образовывал правильную скобочную последовательность необходимо, 
	чтобы $a_L$ было равно $a_R$ (то есть количество открывающих и закрывающих скобок совпало), 
	и так же, ни на каком префиксе $[L:i]$ не нарушился баланс скобок. То есть $a_L \leqslant 
	\min_{i\in[L, R]} a_i$.
	
	При запросе изменения скобки на $j$ позиции нужно пересчитать балансы на суффиксе 
	последовательности после элемента $j$.
	
	Для решения задачи можно воспользоваться $RMQ$, для массива $a_i$ - балансов скобочной 
	последовательности.
	
	\item Попробуем модифицировать идею $\mathbf{SparseTable}$ так, чтобы она работала для 
	произвольных ассоциативных функций: предложите способ выделить $O(n \log n)$ отрезков в 
	массиве размера $n$ так, что любой отрезок $[L, R]$ можно было представить в виде 
	объединения $O(1)$ непересекающихся выделенных отрезков. Заметим, что дерево отрезков 
	выделяет $O(n)$ отрезков, и любой отрезок представляется как объединение $O(log n)$ из них.
	
	\textbf{Решение.}
	
	Сохраним в таблице только значения для отрезков вида $[i, n/2), [n/2, i)$, где $i\in 0, 1, 
	2,..., n - 1$. Аналогично сохраним значения для отрезков вида $[i, n/4), [n/4, i)$, где 
	$i\in 0, 1, 2,..., n/2 - 1$. и $[i, 3n/4), [3n/4, i)$ где $i\in n/2, n/2 + 1,..., n - 1$.
	и т.д. На каждом шаге вычисляем значения для $O(n)$ отрезков. Всего шагов - $O(\log n)$.
	
	Теперь заметим, что при таком разбиении можно любой отрезок разбить на два других, для 
	которых значения уже вычислены. Рассмотрим отрезок $[L, R]$, найдем i, k, такие 
	$\min\limits_{i > 0} : L\leqslant k*n/2^i \leqslant R$
	
	Найдя такие $i, k$ мы сможем разбить отрезок $[L,R] = [L, k*n/2^i) \cup [k*n/2^i, R]$. 
	
	\item Дан массив из $n$ элементов. Запросы: $k$-е по порядку среди различных чисел на отрезке $[L, R]$.
	\begin{itemize}
		\item $offline$ за $O(\log^3 n)$.
		\item $online$ за $O(\log^3 n)$.
	\end{itemize}
	
	\item Придумайте структуру данных, которая поддерживает следующие операции:
	\begin{itemize}
		\item Вставка символа на позицию $i$;
		\item Удаление символов с позиций $[l, r)$;
		\item Копирование подстроки $[l, r)$ в позицию $i$ (пример: $l = 1, r = 4, i = 5 : abcdefg \leftarrow abcdebcdfg$
	\end{itemize}
	
	Все операции должны выполнятся за логарифмическое время от текущей длины текста.
		
	!! Обратите внимание, т.к. теперь распределение вершин в левом и правом поддереве не 
	независимы, свести оценку глубины напрямую к qsort — не получится.	
\end{enumerate}
