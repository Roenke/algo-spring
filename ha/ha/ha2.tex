\section*{RMQ и LCA}
\begin{enumerate}
	\item Дано дерево из одной вершины. Требуется уметь отвечать $online$ за $O(\log n)$ на
	запрос: подвесить новую вершину $u$ к вершине дерева $v$ и вернуть диаметр дерева. Диаметр
	дерева — длина самого длинного простого пути в дереве. 
	
	\textbf{Решение.} 
	
	Заметим, что самый длинный путь в дереве - путь между какими-либо двумя листьями (пусть это 
	не так, и существует путь, хотя бы одна вершина которого - не лист. Но тогда можно 
	продолжить этот путь минимум на 1 вершину. Значит путь не максимальный. Противоречие.)
	
	Заметим, что при добавлении вершины мы всегда добавляем лист. 
	
	Ещё одно \textbf{ утверждение}: \textit{в дереве не может быть два пути максимальной длины 
	(обозначим макс. длину пути $M$), которые не пересекаются.} (Если они есть, то можно 
	построить путь большей длины: выберем самую верхнюю вершину первого пути, и самую верхнюю 
	вершину второго пути. Они не могут совпадать, и между ними есть хотя бы одно ребро. Каждая 
	из этих вершин разбивает соответствующий путь на две части. Выберем из этих частей бОльшие, 
	длина каждой части, минимум, $M / 2$. А значит, можно построить путь длиной не менее $M + 
	1$, что противоречит о максимальности выбранных путей.)
	
	\textbf{Следствие.} Все пути максимальной длины в дереве пересекаются. 
	
	Заметим, что длина максимального пути может измениться не более чем на единицу(т.к. 
	добавляется только 1 вершина и одно ребро), и изменится она только лишь в том случае, когда 
	вершина добавляется к одному из концов какого-либо пути максимальной длины.
	
	Теперь заметим, что поддерживая концевые вершины одного из кратчайших путей, можно понять, 
	изменяет ли добавление вершины длину пути наибольшей длины. Для этого воспользуемся $LCA$, 
	и будем хранить на каком расстоянии от корня находится каждая вершина. Так же будем хранить 
	две вершины(обозначим $v_b, v_e$), которые образуют путь максимальной длины в дереве 
	(сначала она равны одной заданной вершине). При добавлении вершины $u$ будем искать, при 
	помощи $LCA$ ближайшего общего предка для пар вершин $u$, $v_b$, и так же $u$, $v_e$. И, 
	зная расстояния от корня для всех вершин можно будет рассчитать длину путей из $u$ в $v_b$ 
	и из $u$ в $v_e$. Если длина какого либо из них превзойдет длину пути $v_b \to v_e$, то 
	заменим соответствующую вершину на $u$ и вернем полученное значение длины максимального 
	пути.
	
	\textbf{Оценка сложности.} 
	
	Использование $LCA$ имеет сложность $O(\log n)$. Операции вычисления длин двух путей и их 
	сравнение с длинами старых путей, очевидно, константные.
	
	\textbf{Корректность.} 
	
	Осталось сказать, почему хотя бы одна вершина старого пути максимальной длины войдет в 
	новый путь максимальной длины. 
	
	\item Дан ориентированный граф, в котором исходящая степень каждой вершины равна единице.
	Запросы $online$: из вершины $v$ сделать $k$ шагов вперед.
	\begin{itemize}
		\item Предподсчет: $O(n \log k\max)$, время на запрос: $O(\log k)$.
		\item Предподсчет: $O(n \log n)$, время на запрос: $O(\log \min(k, n))$.
	\end{itemize}
	
	\textbf{Решение.}
	
	\begin{itemize}
		\item Предподсчет: $O(n \log k\max)$, время на запрос: $O(\log k)$.
		
		Сделаем скип-лист через каждые $1, 2, 4, 8, 16, ..., k_max$ элементов, тогда сможем за $O(\log k)$ отвечать на запрос.
		\item Предподсчет: $O(n \log n)$, время на запрос: $O(\log \min(k, n))$.
		
		В этом случае нужно воспользоваться структурой графа. В графе обязан быть хотя бы один 
		цикл, поэтому при больших $k$ движение вперед рано или поздно зациклится. Идея в том, 
		чтобы дойти до вершины из цикла, затем убрать лишние циклы из $k$, и пройти оставшееся 
		количество шагов по скиплисту.
		
		На первом шаге алгоритма найдем все циклы в графе с помощью какого-либо обхода, и для 
		каждой вершины сохраним 0, если она не входит ни в какой цикл, и значение длины цикла, 
		если входит. Так же построим скип-лист через каждые $1, 2, 4, 8, 16, ..., n$ вершин. 
		При запросе так же будем двигаться по скип листу, до тех пор, пока не сделаем все шаги, 
		либо пока не попадем в вершину которая лежит в каком-либо цикле. После этого удалим из 
		оставшегося числа шагов полные циклы, и выполним те шаги, что остались. 
		
		\textbf{Оценка сложности.} 
		
		Т.к. теперь скип-лист строится до шага длины $n$, то преподчсчет займет $O(n \log n)$. 
		А т.к. добраться до цикла можно в худшем случае за $O(\log n )$ шагов, а выбросить 
		циклы из значения $k$ займет $O(1)$, то время на запрос составит $O(\log \min(k,n))$. 
	\end{itemize}
	
	\item Дан массив чисел длины $n$. За $O(\log n)$ в $online$ обрабатывать запросы:
	\begin{itemize}
		\item посчитать сумму кубов чисел на отрезке $[L, R]$
		\item прибавить $x$ ко всем числам на отрезке $[L, R]$
		\item получить значение $i$-го числа
	\end{itemize}
	
	\textbf{Решение.}
	
	Воспользуемся $RMQ$, в узле будем хранить значение 
	
	\item Дана скобочная последовательность из круглых скобок длины $n$. Запросы: является ли 
	отрезок $[L, R]$ правильной скобочной последовательностью; изменить $i$-ю скобку. $O(\log n)$, $online$.
	
	\item Попробуем модифицировать идею $\mathbf{SparseTable}$ так, чтобы она работала для 
	произвольных ассоциативных функций: предложите способ выделить $O(n \log n)$ отрезков в 
	массиве размера $n$ так, что любой отрезок $[L, R]$ можно было представить в виде 
	объединения $O(1)$ непересекающихся выделенных отрезков. Заметим, что дерево отрезков 
	выделяет $O(n)$ отрезков, и любой отрезок представляется как объединение $O(log n)$ из них.
	
	\item Дан массив из $n$ элементов. Запросы: $k$-е по порядку среди различных чисел на отрезке $[L, R]$.
	\begin{itemize}
		\item $offline$ за $O(\log^3 n)$.
		\item $online$ за $O(\log^3 n)$.
	\end{itemize}
	
	\item Придумайте структуру данных, которая поддерживает следующие операции:
	
	\begin{itemize}
		\item Вставка символа на позицию $i$;
		\item Удаление символов с позиций $[l, r)$;
		\item Копирование подстроки $[l, r)$ в позицию $i$ (пример: $l = 1, r = 4, i = 5 : abcdefg \leftarrow abcdebcdfg$
	\end{itemize}
	
	Все операции должны выполнятся за логарифмическое время от текущей длины текста.
		
	!! Обратите внимание, т.к. теперь распределение вершин в левом и правом поддереве не 
	независимы, свести оценку глубины напрямую к qsort — не получится.
		
\end{enumerate}


