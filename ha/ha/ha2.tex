\section*{RMQ и LCA}
\begin{enumerate}
	\item Дано дерево из одной вершины. Требуется уметь отвечать $online$ за $O(\log n)$ на
	запрос: подвесить новую вершину $u$ к вершине дерева $v$ и вернуть диаметр дерева. Диаметр
	дерева — длина самого длинного простого пути в дереве. 
	
	\textbf{Решение.} Идея. Заметим, что самый длинный путь в дереве - путь между какими-либо двумя листьями.
	
	Так же, заметим, что при добавлении новой вершины мы обязательно добавим лист. 
	
	
	\item Дан ориентированный граф, в котором исходящая степень каждой вершины равна единице.
	Запросы $online$: из вершины $v$ сделать $k$ шагов вперед.
	\begin{itemize}
		\item Предподсчет: $O(n \log k\max)$, время на запрос: $O(\log k)$.
		\item Предподсчет: $O(n \log n)$, время на запрос: $O(\log \min(k, n))$.
	\end{itemize}
	
	\item Дан массив чисел длины $n$. За $O(\log n)$ в $online$ обрабатывать запросы:
	\begin{itemize}
		\item посчитать сумму кубов чисел на отрезке $[L, R]$
		\item прибавить $x$ ко всем числам на отрезке $[L, R]$
		\item получить значение $i$-го числа
	\end{itemize}
	
	\item Дана скобочная последовательность из круглых скобок длины $n$. Запросы: является ли 
	отрезок $[L, R]$ правильной скобочной последовательностью; изменить $i$-ю скобку. $O(\log n)$, $online$.
	
	\item Попробуем модифицировать идею $\mathbf{SparseTable}$ так, чтобы она работала для произвольных ассоциативных функций: предложите способ выделить $O(n \log n)$ отрезков в массиве размера $n$ так, что любой отрезок $[L, R]$ можно было представить в виде объединения $O(1)$ непересекающихся выделенных отрезков. Заметим, что дерево отрезков выделяет $O(n)$ отрезков, и любой отрезок представляется как объединение $O(log n)$ из них.
	
	\item Дан массив из $n$ элементов. Запросы: $k$-е по порядку среди различных чисел на отрезке $[L, R]$.
	\begin{itemize}
		\item $offline$ за $O(\log^3 n)$.
		\item $online$ за $O(\log^3 n)$.
	\end{itemize}
	
	\item Придумайте структуру данных, которая поддерживает следующие операции:
	
	\begin{itemize}
		\item Вставка символа на позицию $i$;
		\item Удаление символов с позиций $[l, r)$;
		\item Копирование подстроки $[l, r)$ в позицию $i$ (пример: $l = 1, r = 4, i = 5 : abcdefg \leftarrow abcdebcdfg$
	\end{itemize}
	
	Все операции должны выполнятся за логарифмическое время от текущей длины текста.
		
	!! Обратите внимание, т.к. теперь распределение вершин в левом и правом поддереве не 
	независимы, свести оценку глубины напрямую к qsort — не получится.
		
\end{enumerate}


