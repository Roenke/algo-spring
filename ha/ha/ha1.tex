\section*{Декартовы деревья}
\begin{enumerate}
	\item Пусть \textbf{splay}-дерево поддерживает множество $S$. Каждый элемент $x_i \in S$ был запрошен $p_im$ раз, где $m$ — общее число запросов. 
	Гарантируется, что $0 < pi \leqslant 1$ и $\sum_ip_i = 1$. Докажите, что \textbf{splay}-дерево обрабатывает все запросы за время $O(m\cdot \left[1 + \sum_ip_i\cdot \log \frac{1}{p_i} \right])$.

	\item Придумайте структуру данных, поддерживающую упорядоченный список S целых чисел, которая
	умеет отвечать на запросы:
	\begin{itemize}
		\item $insert(x)$ — вставить $x$ в $S$, если его там не было.
		\item $delete(x)$ — удалить $x$ из $S$, если он там был.
		\item $S[k]$ — вернуть $k$-ый по порядку элемент из $S$.
		\item $\max(l, r)$ — найти $\max_{l\leqslant j<k\leqslant r} |S[j] - S[k]|$. Гарантируется $r - l \geqslant 1$.
		\item $\min(l, r)$ — найти $\min_{l\leqslant j<k\leqslant r} |S[j] - S[k]|$. Гарантируется $r - l \geqslant 1$.
	\end{itemize}
	
	Каждый запрос должен обрабатываться за $O(\log |S|)$.
	
	\item Пусть приоритеты случайны, а ключи все разные. Найдите матожидание количества листьев в
	Декартовом дереве из $n$ вершин.
	
	\item Пусть приоритеты случайны, а ключи все разные. Обозначим за $x_k$ вершину Декартова дерева,	содержащую $k$-ый по порядку ключ. Всего в дереве $n$ вершин.
	\begin{itemize}
		\item Пусть $1 \leqslant i \leqslant j \leqslant k \leqslant n$. Найдите вероятность того, что $x_j$ — общий предок $x_i$ и $x_k$.
		\item Пусть $1 \leqslant i \leqslant k \leqslant n$. Найдите матожидание длины пути между $x_i$ и $x_k$.
	\end{itemize}
	
	\item Т.к. обычно приоритеты в Декартовом дереве случайны, то их хранение выглядит избыточным.
	Попробуем их не хранить, а во время операции merge будем делать следующее: если в дереве
	$A$ $n_A$ элементов, а в дереве $B$ $n_B$ элементов, то с вероятностью 
	$\frac{n_A}{n_A + n_B}$ в качестве корня будет выбран корень дерева $A$, а с вероятностью 
	$\frac{n_B}{n_A + n_b}$ в качестве корня будет выбран корень дерева $B$ (далее слияние 
	происходит аналогично слиянию в Декартовом дереве).
	
	Оцените высоту такого дерева поиска.
	
	\item Придумайте структуру данных, которая поддерживает следующие операции:
	
	\begin{itemize}
		\item Вставка символа на позицию $i$;
		\item Удаление символов с позиций $[l, r)$;
		\item Копирование подстроки $[l, r)$ в позицию $i$ (пример: $l = 1, r = 4, i = 5 : abcdefg \leftarrow abcdebcdfg$
	\end{itemize}
	
	Все операции должны выполнятся за логарифмическое время от текущей длины текста.
	
\end{enumerate}

\section*{Дополнительные задачи}
\begin{enumerate}
	\item Придумайте аналог Декартова дерева со случайными приоритетами для хранения точек на плоскости с операциями $splitX, mergeX, splitY, mergeY$. Все операции должны работать за $o(n)$.
\end{enumerate}

