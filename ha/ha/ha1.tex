\section{Декартовы деревья}
\begin{enumerate}
	\item Пусть \textbf{splay}-дерево поддерживает множество $S$. Каждый элемент $x_i \in S$ был запрошен $p_im$ 
	раз, где $m$ — общее число запросов. 
	Гарантируется, что $0 < pi \leqslant 1$ и $\sum_ip_i = 1$. Докажите, что \textbf{splay}-дерево обрабатывает 
	все запросы за время $O(m\cdot \left[1 + \sum_ip_i\cdot \log \frac{1}{p_i} \right])$.

	\textbf{Решение.} 
	
	Введем весовую функцию $\omega(x_i) = p_i$. Тогда $s(x)$ - вес поддерева с корнем в $x$. А $r(x) = \log_2 
	s(x)$ - ранг вершины $x$.
	
	Обозначим $root$ - корень дерева. Из теории известно, что амортизированное время $splay$ не превышает $1 + 
	3(r(root) - r(x)$.
	
	Посчитаем тогда амортизированное время для всех $m$ запросов. 
	\begin{align*}
	m + 3mr(root) - 3\sum\limits_{i = 1}^{n} p_i\cdot m\cdot r(x_i) &\leqslant m + 3mr(root) - 
	3\sum\limits_{i = 1}^{n} p_i\cdot m\cdot \log_2 \omega(x_i)\\
	m(1 + 3 r(root) - 3 \sum\limits_{i = 1}^{n} p_i\cdot \log_2 p_i) &=	m(1 + 3 r(root) + 
	3 \sum\limits_{i = 1}^{n} p_i\cdot \log_2 \frac{1}{p_i})
	\end{align*}
	
	
	Учитывая, что $root$ - корень, и $s(root) = 1$, значит, $r(root) = \log_2 s(root) = 0$, а сумму 
	$\sum\limits_{i = 1}^{n} p_i\cdot \log_2 \frac{1}{p_i}$ можно ограничить снизу и сверху, и, значит, последнее 
	выражение можно переписать в виде $O(m\cdot \left[1 + \sum_ip_i\cdot \log \frac{1}{p_i} \right])$
	
	\item Придумайте структуру данных, поддерживающую упорядоченный список S целых чисел, которая
	умеет отвечать на запросы:
	\begin{itemize}
		\item $insert(x)$ — вставить $x$ в $S$, если его там не было.
		\item $delete(x)$ — удалить $x$ из $S$, если он там был.
		\item $S[k]$ — вернуть $k$-ый по порядку элемент из $S$.
		\item $\max(l, r)$ — найти $\max_{l\leqslant j<k\leqslant r} |S[j] - S[k]|$. Гарантируется $r - l 
		\geqslant 1$.
		\item $\min(l, r)$ — найти $\min_{l\leqslant j<k\leqslant r} |S[j] - S[k]|$. Гарантируется $r - l 
		\geqslant 1$.
	\end{itemize}
	
	Каждый запрос должен обрабатываться за $O(\log |S|)$.
	
	\textbf{Решение.}
	
	Первые три операции могут быть реализованы на любом сбалансированном бинарном дереве с хранением 
	дополнительной информации в узле. 
	
	Для четвертой операции заметим, что требуемый максимум достигается на максимально удаленных друг от друга 
	элементах. Эти элементы имеют индексы $l$ и $r$.
	
	Для пятой задачи нужно искать минимум среди расстояний между соседними элементами. Для вычисления этого 
	значения в поддереве с корнем в вершине $x$ достаточно выбрать минимум из 4 вариантов:

	\begin{itemize}
		\item Решение в $x.left$ = $m_1$
		\item Решение в $x.right$
		\item $|x.key - max(x.left)|$
		\item $|x.key - min(x.right)|$
	\end{itemize}
	\item Пусть приоритеты случайны, а ключи все разные. Найдите матожидание количества листьев в
	Декартовом дереве из $n$ вершин.
	
	\textbf{Решение.}
	
	Идея. Выпишем рекуррентное соотношение для матожидания и решим его.
	Заметим, что любой ключ может попасть в корень с равной вероятностью, которая равна 
	$\frac{1}{n}$. После этого матожидание количества листьев равна сумме матожиданий количества листьев в правом 
	и левом поддеревьях корня. Просуммируем по всем $i$, получим следующее соотношение:
	\begin{equation*}
	E_n = \sum\limits_{i = 1}^{n} (E_{i - 1} + E_{n - i}) \frac{1}{n}
	\end{equation*}
	
	Заметим, что в этой сумме мы все слагаемые $E_i$ посчитали ровно по два раза. Тогда:
	\begin{align*}
	E_n &= \frac{2}{n} \sum\limits_{i = 0}^{n - 1} E_i \\
	\frac{n}{2} E_n &= \sum\limits_{i = 0}^{n - 1} E_i
	\end{align*}
	
	Запишем то же выражение для $n - 1$:
	\begin{equation*}
	\frac{n - 1}{2}E_{n - 1} = \sum\limits_{i = 0}^{n - 2} E_i
	\end{equation*}

	Вычтем его из выражения выше для $E_n$. Получим соотношение для $E_{n - 1}$
	\begin{equation*}
	E_{n - 1} = \frac{n}{2} E_{n} - \frac{n - 1}{2} E_{n - 1}
	\end{equation*}
	
	Упростим его
	\begin{align*}
	\frac{n}{2} E_n &= \frac{n + 1}{2}E_{n - 1} \\
	E_n &= \frac{n + 1}{n} E_{n - 1}
	\end{align*}
	
	Последнее выражение можно последовательно раскрутить, сократив одинаковые выражения в числителе и знаменателе, 
	пока не получим тривиальное значение $E_2 = 1$.
	\begin{equation*}
	E_n = \frac{n + 1}{n} \frac{n}{n - 1} \frac{n - 1}{n - 2} \cdots \frac{4}{3} \cdots E_2 = \frac{n + 1}{3} 
	\cdot 1 = \frac{n + 1}{3}
	\end{equation*}
	
	Таким образом, ответом является значение $\dfrac{n + 1}{3}$
	
	\item Пусть приоритеты случайны, а ключи все разные. Обозначим за $x_k$ вершину Декартова дерева,	
	содержащую $k$-ый по порядку ключ. Всего в дереве $n$ вершин.
	\begin{itemize}
		\item Пусть $1 \leqslant i \leqslant j \leqslant k \leqslant n$. Найдите вероятность того, что $x_j$ — 
		общий предок $x_i$ и $x_k$.
		\item Пусть $1 \leqslant i \leqslant k \leqslant n$. Найдите матожидание длины пути между $x_i$ и $x_k$.
	\end{itemize}
	
	\textbf{Решение.}
	
	\begin{itemize}
		\item Пусть $1 \leqslant i \leqslant j \leqslant k \leqslant n$. Найдите вероятность того, что $x_j$ — 
		общий предок $x_i$ и $x_k$.
		
		\textbf{Решение.} Рассмотрим последовательность ключей $x_1, x_2, ..., x_i, ..., x_j,..., x_k, ..., x_n$.
		
		Заметим, что декартово дерево можно строить следующим образом: среди всех элементов с равной вероятностью 
		выбрать элемент, сделать его корнем, повторить эту процедуру рекурсивно для правой и левой частей. 
		Очевидно, такой способ эквивалентен построению дерева по имеющимся приоритетам.
		
		Так же заметим, что для того, чтобы $x_j$ был общим предком $x_i$ и $x_k$ необходимо и достаточно, чтобы 
		в описанном выше алгоритме $x_j$ был выбран первым из отрезка $[x_i, x_k]$. ($\Rightarrow$ предположим 
		противное, и $x_j$ общий предок, а выбран был другой элемент $x_p$, но тогда $x_j$ больше не сможет быть 
		предком для одного из элементов $x_i$ или $x_k$. $\Leftarrow$ если его выбрали, то $x_i$ и $x_k$ 
		находятся в правом и левом поддереве от $x_j$, следовательно $x_j$ их общий предок.)
		
		Значит вероятность того, что $x_j$ общий предок $x_i$, $x_k$ равно 1 / \{количество элементов в отрезке 
		$[x_i, x_k]$\}. То есть $\dfrac{1}{k - i + 1}$
		
		\item Пусть $1 \leqslant i \leqslant k \leqslant n$. Найдите матожидание длины пути между $x_i$ и $x_k$.
		
		\textbf{Решение.} Заметим, что длину пути $P(x_i, x_j)$ между двумя вершинами $x_i$, $x_j$ в дереве можно 
		выразить следующим образом:
		\begin{equation*}
		P(x_i, x_j) = P(x_i, root) + P(x_j, root) - 2P(x_v, root) + 1
		\end{equation*}
		
		где $x_v$ - вершина, в которой пути $P(x_i, root), P(x_j, root)$ пересекаются в первый раз.
		
		Матожидание функция линейная, поэтому, получим значение матожидания для введённой выше формулы, получим 
		матожидание длины пути между вершинами в декартовом дереве.
		
		Обозначим $A(i, j)$ - вершина $i$ является предком вершины $j$. $B(i, j, k)$ - вероятность того, что 
		вершина $j$ является общим предком вершин $i, k$. Для $B$, справедливо соотношение, полученном в 
		предыдущем пункте: $B = \dfrac{1}{k - i + 1}$, для $A$ его несложно получить из тех же рассуждений: $A(i, 
		j) = \dfrac{1}{j - i + 1}$.
		
		Для получения конечного ответа достаточно вычислить значение матожидания:
		\begin{equation*}
		E = \sum\limits_{j\neq i}(A(i, j) - B(i, j, k)) + \sum\limits_{j \neq k}(A(j, k) - B(i, j, k))
		\end{equation*}
		
		Если посмотреть на вид соотношений для $A$ и $B$, то можно сделать вывод, что $E$ это сумма некоторых 
		первых членов гармонических рядов, причём с увеличением $n$ она сходится к $O(\log n)$.	
	\end{itemize}
	
	\item Т.к. обычно приоритеты в Декартовом дереве случайны, то их хранение выглядит избыточным.
	Попробуем их не хранить, а во время операции merge будем делать следующее: если в дереве
	$A$ $n_A$ элементов, а в дереве $B$ $n_B$ элементов, то с вероятностью 
	$\frac{n_A}{n_A + n_B}$ в качестве корня будет выбран корень дерева $A$, а с вероятностью 
	$\frac{n_B}{n_A + n_b}$ в качестве корня будет выбран корень дерева $B$ (далее слияние 
	происходит аналогично слиянию в Декартовом дереве).
	
	Оцените высоту такого дерева поиска.
	
	\textbf{Решение.}
	
	Достаточно заметить, что это эквивалентно обычному мержу. Когда происходит обычный мерж двух деревьев из 
	$n_A$ и $n_B$ элементов, то, вероятность, что какая-либо из всех вершин этих деревьев станет корнем равна 
	$\frac{1}{n_A}$. Теперь, допустим, мы знаем, что эта вершина из $A$, а т.к таких вершин $n_A$, то и 
	соответствующая вероятность равна $\frac{n_A}{n_A + n_B}$. Для дерева $B$ рассуждения аналогичны, таким 
	образом, описанный алгоритм эквивалентен обычному мержу, значит все свойства декартова дерева выполнятся, в 
	том числе и оценка на высоту - $O(\log n)$
	
	\item Придумайте структуру данных, которая поддерживает следующие операции:
	
	\begin{itemize}
		\item Вставка символа на позицию $i$;
		\item Удаление символов с позиций $[l, r)$;
		\item Копирование подстроки $[l, r)$ в позицию $i$ (пример: $l = 1, r = 4, i = 5 : abcdefg \leftarrow 
		abcdebcdfg$
	\end{itemize}
	
	Все операции должны выполнятся за логарифмическое время от текущей длины текста.
	
	\textbf{Решение.}
	Воспользуемся персистентным декартовым деревом, следовательно операции будут занимать логарифмическом время 
	от длины текста. Единственная проблема - мерж с собой же, при котором будут одинаковые приоритеты. Решить эту 
	проблему можно, воспользовавшись решением предыдущей задачи.
	
\end{enumerate}

\section*{Дополнительные задачи}
\begin{enumerate}
	\item Придумайте аналог Декартова дерева со случайными приоритетами для хранения точек на плоскости с 
	операциями $splitX, mergeX, splitY, mergeY$. Все операции должны работать за $o(n)$.
\end{enumerate}
