\section*{Декартовы деревья}
\begin{enumerate}
	\item Пусть \textbf{splay}-дерево поддерживает множество $S$. Каждый элемент $x_i \in S$ был запрошен $p_im$ раз, где $m$ — общее число запросов. 
	Гарантируется, что $0 < pi \leqslant 1$ и $\sum_ip_i = 1$. Докажите, что \textbf{splay}-дерево обрабатывает все запросы за время $O(m\cdot \left[1 + \sum_ip_i\cdot \log \frac{1}{p_i} \right])$.

	\textbf{Решение.} 
	
	
	
	\item Придумайте структуру данных, поддерживающую упорядоченный список S целых чисел, которая
	умеет отвечать на запросы:
	\begin{itemize}
		\item $insert(x)$ — вставить $x$ в $S$, если его там не было.
		\item $delete(x)$ — удалить $x$ из $S$, если он там был.
		\item $S[k]$ — вернуть $k$-ый по порядку элемент из $S$.
		\item $\max(l, r)$ — найти $\max_{l\leqslant j<k\leqslant r} |S[j] - S[k]|$. Гарантируется $r - l \geqslant 1$.
		\item $\min(l, r)$ — найти $\min_{l\leqslant j<k\leqslant r} |S[j] - S[k]|$. Гарантируется $r - l \geqslant 1$.
	\end{itemize}
	
	Каждый запрос должен обрабатываться за $O(\log |S|)$.
	
	\item Пусть приоритеты случайны, а ключи все разные. Найдите матожидание количества листьев в
	Декартовом дереве из $n$ вершин.
	
	\textbf{Решение.}
	
	Идея. Выпишем рекуррентное соотношение для матожидания и решим его.
	Заметим, что любой ключ может попасть в корень с равной вероятностью, которая равна 
	$\frac{1}{n}$. После этого матожидание количества листьев равна сумме матожиданий количества листьев в правом и левом поддеревьях корня. Просуммируем по всем $i$, получим следующее соотношение:
	
	$$E_n = \sum\limits_{i = 1}^{n} (E_{i - 1} + E_{n - i}) \frac{1}{n}$$
	
	Заметим, что в этой сумме мы все слагаемые $E_i$ посчитали ровно по два раза. Тогда:
	
	$$E_n = \frac{2}{n} \sum\limits_{i = 0}^{n - 1} E_i$$
	
	$$\frac{n}{2} E_n = \sum\limits_{i = 0}^{n - 1} E_i$$
	
	Запишем то же выражение для $n - 1$:
	
	$$\frac{n - 1}{2}E_{n - 1} = \sum\limits_{i = 0}^{n - 2} E_i$$

	Вычтем его из выражения выше для $E_n$. Получим соотношение для $E_{n - 1}$
	
	$$E_{n - 1} = \frac{n}{2} E_{n} - \frac{n - 1}{2} E_{n - 1}$$
	
	Упростим его
	
	$$\frac{n}{2} E_n = \frac{n + 1}{2}E_{n - 1}$$
	
	$$E_n = \frac{n + 1}{n} E_{n - 1}$$
	
	Последнее выражение можно последовательно раскрутить, сократив одинаковые выражения в числителе и знаменателе, пока не получим тривиальное значение $E_2 = 1$.
	
	$$E_n = \frac{n + 1}{n} \frac{n}{n - 1} \frac{n - 1}{n - 2} \cdots \frac{4}{3} E_2 = \frac{n + 1}{3} \cdot 1 = \frac{n + 1}{3}$$
	
	Таким образом, ответом является значение $\dfrac{n + 1}{3}$
	
	\item Пусть приоритеты случайны, а ключи все разные. Обозначим за $x_k$ вершину Декартова дерева,	содержащую $k$-ый по порядку ключ. Всего в дереве $n$ вершин.
	\begin{itemize}
		\item Пусть $1 \leqslant i \leqslant j \leqslant k \leqslant n$. Найдите вероятность того, что $x_j$ — общий предок $x_i$ и $x_k$.
		\item Пусть $1 \leqslant i \leqslant k \leqslant n$. Найдите матожидание длины пути между $x_i$ и $x_k$.
	\end{itemize}
	
	\item Т.к. обычно приоритеты в Декартовом дереве случайны, то их хранение выглядит избыточным.
	Попробуем их не хранить, а во время операции merge будем делать следующее: если в дереве
	$A$ $n_A$ элементов, а в дереве $B$ $n_B$ элементов, то с вероятностью 
	$\frac{n_A}{n_A + n_B}$ в качестве корня будет выбран корень дерева $A$, а с вероятностью 
	$\frac{n_B}{n_A + n_b}$ в качестве корня будет выбран корень дерева $B$ (далее слияние 
	происходит аналогично слиянию в Декартовом дереве).
	
	Оцените высоту такого дерева поиска.
	
	\item Придумайте структуру данных, которая поддерживает следующие операции:
	
	\begin{itemize}
		\item Вставка символа на позицию $i$;
		\item Удаление символов с позиций $[l, r)$;
		\item Копирование подстроки $[l, r)$ в позицию $i$ (пример: $l = 1, r = 4, i = 5 : abcdefg \leftarrow abcdebcdfg$
	\end{itemize}
	
	Все операции должны выполнятся за логарифмическое время от текущей длины текста.
	
\end{enumerate}

\section*{Дополнительные задачи}
\begin{enumerate}
	\item Придумайте аналог Декартова дерева со случайными приоритетами для хранения точек на плоскости с операциями $splitX, mergeX, splitY, mergeY$. Все операции должны работать за $o(n)$.
\end{enumerate}

