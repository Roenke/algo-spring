\section*{Поиск подстроки в строке}
\begin{enumerate}
	\item Найти подстроку в тексте. При сравнении строк можно делать циклический сдвиг алфавита в одной из них. 
	$O(n + m)$, алфавит — не константа.
	
	\textbf{Решение.}
	
	Пусть есть текст $T = a_1a_2...a_n$, и подстрока $s = b_1b_2...b_m$, которую хотим найти. Перекодируем текст и 
	строку следующим образом:
	\begin{align*}
		& T = 0(a_2 - a_1)(a_3 - a_2)...(a_n - a_{n - 1}) \\
		& s = 0(b_2 - b_1)(b_3 - b_2)...(b_m - b_{m - 1})
	\end{align*}
	
	Теперь циклический сдвиг не на что не влияет, значит можно воспользоваться $Z$ - функцией для поиска подстроки 
	$s$ в тексте $T$.
	
	\item Для каждого префикса строки найти количество его префиксов равных его суффиксу. $O(n)$.
	
	\textbf{Решение.}
	
	Сначала вычислим префикс-функцию $p$. Заметим, что префикса длины $i$ нам нужно знать суффиксы длины $p[i], 
	p[p[i]]...$. Эта идея позволяет воспользоваться динамикой:
	\begin{align*}
		& d[0] = 0 \\
		& d[i] = d[p[i]] + 1
	\end{align*}
	Сложность, очевидно, $O(n)$.
	
	\item Преобразовать $Z$-функцию в префикс-функцию без промежуточного восстановления строки. $O(n)$.
	
	\textbf{Решение.}
	
	Например, можно так ($p$ - массив, задающий префикс-функцию, изначально заполнен нулями, $z$ - массив с $z$- 
	функцией):
	\begin{lstlisting}
for i = 0 to n
	for j = z[i] - 1 to 0
		if (p[i + j] == 0) then
			break
		else
			p[i + j] = j + 1
		endif
	\end{lstlisting}
	
	Заметим, что внутренний цикл за все время содержит не более одного присваивания значения в каждую ячейку 
	массива $p$, поэтому сложность $O(n)$. 
	\item[5.] Даны бор $A$ и строка $s$. Нужно вернуть вершину бора $v$, от которой строку $s$ можно отложить вниз. 
	Размер алфавита $O(1)$. Время $O(|A| + |s|)$.
	
	\textbf{Решение.}
	Для начала добавим строку $s$ в бор, запомним вершину бора $u$, где строка $s$ закончилась. Теперь построим 
	суффиксные ссылки с помощью обхода в ширину. Заметим, что если есть переход от которого вершины $z$ по 
	суффиксной ссылке в $u$, то в качестве $v$ можем взять вершину на $|s|$ узлов выше $z$. Если такого перехода 
	нет, то и строку $s$ отложить не удастся. 
	
	Сложность $O(|A|)$ - чтобы построить суффиксные ссылки, и $O(|s|)$, чтобы подняться до $v$. Итого $O(|A| + 
	|s|)$.
	
	\item[6.] В словаре могут добавляются и удаляются слова. Необходимо в \textit{online} научится отвечать на запрос 
	$\mathbf{get(t)}$ вида “входит ли в текст $t$ хоть одно словарное слово”. Амортизированное время работы 
	$\mathbf{add(s)}$ и $\mathbf{del(s)}$: $O(|s| \log L)$, время работы $\mathbf{get(t)}$: $O(|t| \log L)$ ($L$ — 
	суммарная длина всего). Подсказка: заведите порядка $\log L$ боров.
	
	\item[7.] Дан набор словарных слов. Придумать самую короткую строку, допускающей более одного разбиения на 
	словарные слова или сообщить, что такой нет. Время работы — полином от суммы длин слов и размера алфавита.
\end{enumerate}
