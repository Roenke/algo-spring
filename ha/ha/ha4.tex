\section*{Хеширование}
\begin{enumerate}
	\item Семейство хэш-функций $\mathcal{H} = \{h : X \rightarrow Y \}$ называется универсальным, если:
	
	\begin{equation*}
	\forall x_1, x_2 \in X, x_1 \neq x_2 : \underset{h \in \mathcal{H}}{\mathbf{Pr}} \left[h(x_1) = h(x_2)\right] 
	\leqslant \frac{1}{|Y|}
	\end{equation*}
	
	Семейство хэш-функций $\mathcal{H} = \{h : X \rightarrow Y \}$ называется $k$-независимым, если для любых 
	различных $x_1, x_2, \cdots , x_k \in X$, для любых, возможно совпадающих, выполняется: $y_1, y_2, \cdots, 
	y_k \in Y$
	
	\begin{equation*}
	 \underset{h \in \mathcal{H}}{\mathbf{Pr}} \left[\bigwedge\limits_{i = 1}^{k} h(x_i) = y_i\right] = 
	 \frac{1}{|Y|^k}
	\end{equation*}
		
	\begin{enumerate}
		\item Докажите, что из любое 2-независимое семейство хэш-функций является универсальным.
		\item Докажите, что любое $k + 1$-независимое семейство хэш-функций является $k$-независимым.
	\end{enumerate}
	
	
	\item В вашем распоряжении есть пара 2-независимых семейств хеш-функций $\mathcal{A} = \{f : A \rightarrow 
	F_2^n \}$ и $\mathcal{B} = \{g : B \rightarrow F_2^n \}$. Постройте (и докажите, что построено правильно) 
	универсальное семейство хеш-функций, которое:
	\begin{enumerate}
		\item будет отправлять пары типа $(A, B)$ в $F_2^n$,
		\item будет отправлять мультимножества из элементов типа $A$ в $F_2^n$,
		\item будет отправлять множества из элементов типа $A$ в $F$,
		\item будет отправлять списки из элементов типа $A$ в $F_2^n$.
	\end{enumerate}
	
	\item Используя функцию из задания 10 с практики, постройте семейство 2-независимых хэш-функций $\mathcal{H} 
	= \{h_i: \mathbb{F}^n_2 \rightarrow \mathbb{F}^n_2\}_i$ Докажите, что семейство является 2-независимым.
		
	\item[4*.] Пусть дана хэш-таблица размера $n$ с хэш-функцией $h : K \rightarrow [n]$. На вход поступает $n$ 
	ключей. Будем предполагать, что хэш-функция отправляет каждый ключ в каждую ячейку независимо с равной 
	вероятностью. Коллизии разрешаются с помощью односвязных списков, цепочек. Посчитаем максимальную длину 
	цепочки.
	
	\begin{enumerate}
		\item Зафиксируем хэш-значение $x$. Доказать, что вероятность, что $k$ ключей будут иметь хэш $x$ 
		составляет
		
		\begin{equation*}
			Q_k = \binom{n}{k}\cdot \left( \frac{1}{n} \right)^k \cdot \left(1 - \frac{1}{n} \right)^{n-k}
		\end{equation*}
		
		\textbf{Решение.} Раз уж испытания независимы, то можно их интерпретировать как схему Бернулли. Первый 
		множитель, это количество способов выбрать $k$ элементов из $n$, значение хеша от которых равно $x$. 
		Второй множитель - вероятность, что эти $k$ элементов перейдут в $x$. Последний множитель - вероятность, 
		что остальные $n - k$ элементов перейдут во что-то другое, но не $x$.
		
		\item Пусть $P_k$ – вероятность максимальной цепочки иметь длину $k$. Доказать, что $P_k \leqslant n 
		\cdot Q_k$.
		
		\textbf{Решение.} Посмотрим что значат вероятность справа. Она означает, что имеется хотя бы одна 
		цепочка, длина которой равна $k$. А слева то же самое, но усиленное утверждением, что больше чем $k$ 
		нету. Следовательно событие слева вложено в событие справа, а значит и для вероятностей справедливо 
		записанное неравенство.
		
		\item Вывести из Стрилинга, что $Q_k \le \left(\dfrac{e}{k}\right)^k$
		\item Показать, что для некоторого $c \ge 1$ верно $Q_k \leqslant c \cdot \dfrac{\log n}{\log \log n}$.
	\end{enumerate}
	
	\item[7.] Пусть мы можем потратить не более 100 байт памяти на предподсчет. Нужно научится по 64-битному 
	числу вида $2^k$ восстанавливать $k$ за $O(1)$ арифметических операций и единственное
	чтение одного байта из предподсчитанных данных. Напишите псевдокод предподсчета и ответа на 
	запрос.
	
	\textbf{Решение.}
	
	Для решения этой задачи нам потребуется циклическая группа, элемент-генератор которой равен $2$, а количество 
	элементов превосходит 64. Для этих целей нам подойдут 2 группы $\mathbb{Z}_{67}$ и $\mathbb{Z}_{83}$ по 
	умножению. Выберем $\mathbb{Z}_{67}$. Тогда каждая степень двойки перейдёт в свой элемент группы и мы сможем 
	числа $2^0, 2^1, 2^2, ..., 2^{63}$ однозначным образом хешировать (Одного байта, чтобы записать степень, не превосходящую 64 нам вполне достаточно.). То есть преподсчет будет следующий:
	\begin{lstlisting}
	byte buf[100]
	for k = 0..63:
		buf[2**k % 67] = k
	\end{lstlisting}
	А для определения степени $k$ для значения $p$ можно воспользоваться:
	\begin{lstlisting}
	k = buf[p % 67]
	\end{lstlisting}
	
	\item[8.] Вам даны два корневых дерева, большое $T$ и маленькое $t$. Требуется найти такую вершину $x$
	дерева $T$, что поддерево, индуцированное вершиной $x$, и $t$ изоморфны.
	
	Решайте в предположении, что у вас есть хорошие хеш-функции для списков.
	
	\begin{enumerate}
		\item При проверке на изоморфизм порядок детей важен,
		
		\textbf{Решение.} В каждой вершине дерева $T$ будем хранить значение хеша, которое соответствует его 
		поддереву. Чтобы вычислить хеш, необходимо: во все листья записать значение хеша равный $0$. Хеш вершине 
		равен хешу списка хешей потомков(список содержит хеши в порядке потомков). Осталось аналогичным образом 
		вычислить хеш для дерева $t$ и проверить, встречается ли это значение в хешах для какой-либо вершины 
		дерева $T$. 
		
		\item При проверке на изоморфизм порядок детей не важен.
		
		\textbf{Решение.} Аналогично предыдущему пункту, с той лишь разницей, что прежде чем вычислять хеш от 
		списка с хешами потомков, этот список нужно отсортировать, тогда порядок потомков станет не важен. 
	\end{enumerate}
	
	\textbf{Дополнительная задача.}
	
	\item[1.] Придумайте решение последней задачи без использования хеш-функций.
	
	Решение описано в статье:
	
	\url{http://logic.pdmi.ras.ru/~smal/files/smal_jass08.pdf}
	
	\textbf{Задача про фильтр Блума.}
	
	\item[1.] Пусть имеется фильтр Блума длины $m$ с $k$ функциями. Фильтр Блума можно использовать для подсчета количества 
	различных элементов в множестве. Известно, что матожидание количества бит, выставленных фильтром Блума $n(A)$ 
	связанно с количеством различных элементов в множестве $A$ следующей функцией:
	\begin{equation}
		|A| = - \dfrac{m \ln (1-\frac{n(A)}{m})}{k}
	\end{equation}
	Придумайте, как, имея фильтры Блума для множества $A$ и $B$, оценить размер пересечения и размер объединения 
	данных множеств.
	
	\textbf{Решение.} Достаточно вспомнить с практики, что для объединения будет просто дизъюнкция. 
	
	А размер пересечения можно получить из формулы включения-исключения:
	
	$|A \cap B| = |A| + |B| - |A \cup B|$
	
\end{enumerate}


