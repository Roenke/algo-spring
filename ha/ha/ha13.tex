\section*{Суффиксные структуры}
\begin{enumerate}
	\item Найдите усреднённое по всем парам суффиксов значение $lcp$ для строки длины $n$ с помощью	суффиксного массива за $O(n)$.
	
		\textbf{Решение.} 
		
		Для начала построим суффиксный массив, и по нему массив $lcp$. Теперь заполним два массива $L[0..n-1], 
		R[0..n-1]$ - где $[L[i], R[i])$ - интервал на котором $i$-ый элемент массива $lcp$ минимален. Заведём 
		стек, и пробежим $r$ от $1$ до $n$, при этом, если $lcp[r]$ больше элемента на стеке, то добавим его в 
		стек, если меньше, то заполним $R[top(stack)] = r$ и вытолкнем элемент со стека, повторим это пока 
		$lcp[r] > top(stack)$. Когда $r$ дойдёт до $n + 1$ нужно будет опустошить стек, заполнив для оставшихся 
		элементов $R[elem] = r$. 
		
		Проделав то же самое для развёрнутой строки, получим массив $L$. Осталось лишь найти среднее. Это будет 
		величина 
		\begin{equation*}
		mid = \left[ \sum\limits_{i = 0}^{n - 1}  (i - L[i]) \cdot (R[i] - i) \cdot lcp[i] \right] / \frac{n(n + 1)}{2}
		\end{equation*}
		
		Сложность, очевидно, $O(n)$.
		
	\item[3.] Найдите максимальный рефрен — такую подстроку строки $s$, что количество ее вхождений (возможно пересекающихся) помноженных на ее длину — максимально. Решите двумя способами: суффиксными деревом и массивом.
	
	\begin{itemize}
		\item \textit{Суффиксное дерево:} построим суффиксное дерево. Для каждой вершины вычислим две величины: 
		длина строки, соответствующей пути от корня до вершины - $length[v]$, и количество листьев в поддереве 
		вершины $leaves[v]$. Первая величина соответствует длине, вторая - количество вхождений, $v$ - некоторая 
		подстрока. 
		
		Таким образом, ответом на задачу будет являться такая $v$, для которой значение $length[v] \cdot leaves[v] 
		\to \max$.
		
		Сложность решения составляется $O(n)$, т.к. нужно построить дерево и выполнить обход суффиксного дерева.
		
		\item \textit{Суффиксный массив:} Построим суффиксный массив. Осталось найти максимум среди отрезков $[l, 
		r]$, где $1 \leq l \leq r \leq n$:
		\begin{equation*}
			(r - l + 1) \cdot \min \limits_{i \in [l, r)} \left[ lcp(p_i, p_{i + 1}) \right]
		\end{equation*}
		
		Так можно сделать, т.к. префикс суффикса $p_l$ длины $\min \limits_{i \in [l, r)} \left[ lcp(p_i, p_{i + 
		1}) \right]$ входит в строку по крайней мере $(r - l + 1)$ раз. Т.к. сложность не требуется, то можно 
		воспользоваться произвольным алгоритмом поиска $lcp$, и вычислять заданное соотношение "в лоб".
		
	\end{itemize}
	\item[4.] Дан набор строк $s_i$ суммарной длины $n$. Для каждой $s_i$ найдите $min$ по длине подстроку, которая не встречается в других. $O(n)$.
	
	\textbf{Решение.} 
	
	Построим суффиксное дерево для строки $s_1a_1s_2a_2\dots a_{n - 1}s_na_n$. Где $a_i$ - некоторые 
	символы-разделители, которые не встречаются в исходной строке. Теперь выполним обход суффиксного дерева и 
	заполним информацию в узлах дерева $info = i$, в поддереве находится разделитель $a_i$, и никаких других 
	разделителей нет. Если же разделителей несколько, то запишем значение $+\infty$. 
	
	После этого осталось для каждой $s_i$ найти минимальную подстроку, из соответствующего узла суффиксного 
	дерева которой можно достичь ровно один терминальный символ.
	
	Сложность: Дерево может построить за $O(n)$, несколько обходов так же за $O(n)$, итоговая сложность $O(n)$.
	
	\item[5.] Даны $k$ строк суммарной длины $n$. Найдите $p$-ю лексикографически общую их подстроку за $O(n)$.
	
	\textbf{Решение} Запишем данные $k$ строк в одну строку $s_1\#s_2\#..\#s_n\#$ и построим для неё суффиксный 
	массив. Так же заведём $k$ длин суффиксов для каждой из строк.  Ещё заведём очередь с минимумом на отрезке 
	$[L, R]$, где $L$ самый короткий суффикс, $R$ - самый длинный. Тогда $LCP(L,R)$ может получить, как минимум 
	из очереди. Т.к. такой обход обеспечивает лексикографический порядок, то искомая подстрока будет 
	соответствовать отрезку $k-$му отрезку $[L, R]$ с ненулевым значением $LCP$. Чтобы сдвинуть сказатели можно 
	воспользоваться след. соотношениями: $L.next := L + 1, R.next = max(R, L.next)$.
\end{enumerate}
